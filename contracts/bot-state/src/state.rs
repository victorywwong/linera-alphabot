use linera_sdk::views::{linera_views, RegisterView, RootView, ViewStorageContext};
use serde::{Deserialize, Serialize};

/// The application state for a trading bot
#[derive(RootView, async_graphql::SimpleObject)]
#[view(context = ViewStorageContext)]
pub struct BotState {
    /// Unique identifier for this bot (e.g., "momentum", "sentiment")
    pub bot_id: RegisterView<String>,

    /// The latest signal published by this bot
    pub latest_signal: RegisterView<Option<Signal>>,

    /// Rolling accuracy metrics for the last 24 hours
    pub accuracy_24h: RegisterView<AccuracyMetrics>,

    /// Total count of users following this bot
    pub follower_count: RegisterView<u64>,
}

/// A prediction signal generated by the bot
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, async_graphql::SimpleObject)]
#[graphql(input_name = "SignalInput")]
pub struct Signal {
    /// Unix timestamp (milliseconds) when signal was generated
    pub timestamp: u64,

    /// Trading action recommendation
    pub action: Action,

    /// Predicted ETH price in micro-USD (multiply USD by 1_000_000)
    /// Example: $3500.25 = 3_500_250_000
    pub predicted_price_micro: u64,

    /// Confidence in basis points (0-10000, where 10000 = 100%)
    /// Example: 95.5% = 9550
    pub confidence_bps: u64,

    /// Human-readable reasoning (max 512 chars)
    pub reasoning: String,

    /// Actual price at resolution time in micro-USD (populated later)
    pub actual_price_micro: Option<u64>,
}

/// Trading action types
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, async_graphql::Enum)]
pub enum Action {
    Buy,
    Sell,
    Hold,
}

/// Accuracy metrics computed over a time window
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, async_graphql::SimpleObject)]
pub struct AccuracyMetrics {
    /// Root Mean Square Error in micro-USD
    pub rmse_micro: u64,

    /// Directional accuracy in basis points (0-10000, where 10000 = 100%)
    /// Example: 95.5% = 9550
    pub directional_accuracy_bps: u64,

    /// Number of predictions in this window
    pub total_predictions: u64,

    /// Number of correct directional calls
    pub correct_predictions: u64,

    /// Last updated timestamp
    pub last_updated: u64,
}

impl Default for AccuracyMetrics {
    fn default() -> Self {
        Self {
            rmse_micro: 0,
            directional_accuracy_bps: 0,
            total_predictions: 0,
            correct_predictions: 0,
            last_updated: 0,
        }
    }
}

impl Signal {
    /// Validate signal constraints
    pub fn validate(&self) -> Result<(), String> {
        if self.confidence_bps > 10_000 {
            return Err("Confidence must be between 0 and 10000 basis points".to_string());
        }

        if self.predicted_price_micro == 0 {
            return Err("Predicted price must be positive".to_string());
        }

        if self.reasoning.len() > 512 {
            return Err("Reasoning must be <= 512 characters".to_string());
        }

        if self.timestamp == 0 {
            return Err("Timestamp must be non-zero".to_string());
        }

        Ok(())
    }

    /// Check if this signal's directional prediction was correct
    pub fn is_directionally_correct(&self, previous_price_micro: u64) -> Option<bool> {
        self.actual_price_micro.map(|actual| {
            match self.action {
                Action::Buy => actual > previous_price_micro,
                Action::Sell => actual < previous_price_micro,
                Action::Hold => {
                    // Within 2%: |actual - prev| / prev < 0.02
                    let diff = if actual > previous_price_micro {
                        actual - previous_price_micro
                    } else {
                        previous_price_micro - actual
                    };
                    // diff / prev < 0.02 => diff < prev * 0.02
                    diff < previous_price_micro / 50 // 1/50 = 0.02 = 2%
                },
            }
        })
    }
}

impl AccuracyMetrics {
    /// Update metrics with a new resolved signal
    pub fn update(&mut self, signal: &Signal, previous_price_micro: u64, current_timestamp: u64) {
        if let Some(actual) = signal.actual_price_micro {
            self.total_predictions += 1;

            // Update directional accuracy
            if let Some(correct) = signal.is_directionally_correct(previous_price_micro) {
                if correct {
                    self.correct_predictions += 1;
                }
            }

            // Calculate directional accuracy in basis points (0-10000)
            self.directional_accuracy_bps = if self.total_predictions > 0 {
                (self.correct_predictions * 10_000) / self.total_predictions
            } else {
                0
            };

            // Update RMSE in micro-USD (simplified: single error, not running average)
            let error_micro = if signal.predicted_price_micro > actual {
                signal.predicted_price_micro - actual
            } else {
                actual - signal.predicted_price_micro
            };
            self.rmse_micro = error_micro;

            self.last_updated = current_timestamp;
        }
    }
}
